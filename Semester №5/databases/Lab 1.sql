--------------------------------------------------
-- Задание 1
--------------------------------------------------

select Пол, avg(Заработная_плата)
from Сотрудник
group by Пол

--------------------------------------------------
-- Задание 2
--------------------------------------------------

select Владелец, Тип, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Помещение
group by Владелец, Тип

--------------------------------------------------
-- Задание 3
--------------------------------------------------

select substring(upper(Пол), 1, 1), max(Заработная_плата)
from Сотрудник
group by substring(upper(Пол), 1, 1)

--------------------------------------------------
-- Задание 4
--------------------------------------------------

select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by Пол

--------------------------------------------------
-- Задание 5
--------------------------------------------------

select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by rollup (Пол)

select Пол, Клиент.ID, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by rollup (Пол, Клиент.ID)

--------------------------------------------------
-- Задание 6
--------------------------------------------------

-- В этом случае cube ничем не будет отличатся от rollup, 
-- потому что мы группируем по одному столбцу.
select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by cube (Пол)

-- В этом случае cube переберёт все возможные комбинации столбцов:
--
--     Пол, Клиент.ID
--     Пол
--     Клиент.ID
--     ()
--
-- В то время, как rollup переберет только
--
--     Пол, Клиент.ID
--     Пол
--     ()
select Пол, Клиент.ID, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by cube (Пол, Клиент.ID)

--------------------------------------------------
-- Задание 7
--------------------------------------------------

select Пол, Клиент.ID, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by
grouping sets((Пол), (Клиент.ID))

--------------------------------------------------
-- Задание 8
--------------------------------------------------

-- В данном запросе cube сгруппирует резльтаты по всем
-- возможным кобинациями столбцов:
--
--     Пол
--     ()
select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by cube (Пол)

-- Rollup сгруппирует результаты по иерархии стоблцов:
--
--     Пол
--     ()
select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by rollup (Пол)

-- Grouping sets сгруппирует результаты по всем перечисленным
-- множествам группировки:
--
--     Пол
--     ()
select Пол, sum(cast(Доступно_для_покупки as int)) as "Количество доступных для покупки"
from Клиент
join Помещение
on Клиент.ID = Помещение.Владелец
group by grouping sets ((Пол), ())

-- Видно, что во всех трех случаях множества группировки получились
-- одинаковыми. Значит все три этих запроса эквивалентны.

--------------------------------------------------
-- Задание 9
--------------------------------------------------

select
	isnull(Пол,
		case when grouping(Пол) = 1 and grouping(Клиент.ID) = 0
		then 'Все'
		else 'Неизвестно'
	end) as 'Пол',
	isnull(cast(Клиент.ID as varchar(30)),
		case when grouping(Клиент.ID) = 1 and grouping(Пол) = 0
		then 'Все'
		else 'Неизвестно'
	end) as'Клиент.ID',
	sum(cast(Доступно_для_покупки as int)) as 'Количество доступных для покупки'
from Клиент
join Помещение on Клиент.ID = Владелец
group by rollup (Пол, Клиент.ID)

--------------------------------------------------
-- Задание 10
--------------------------------------------------

-- Просто нумеруют выводимые строки.
select row_number() over(order by ID) as "№ строки", *
from Сотрудник

-- Каждой строке в разбиении (partition) присваивает
-- одинаковый ранг.
select rank() over(order by Статус), *
from Сотрудник

-- В отличие от rank() числа, возвращаемые dense_rank()
-- не имеют пробелов (gaps), т. е. идут подряд.
select dense_rank() over(order by Статус), *
from Сотрудник

-- Просто разбивает записи в таблице на N разбиений. 
select ntile(4) over(order by Статус), *
from Сотрудник

--------------------------------------------------
-- Задание 11
--------------------------------------------------

select row_number() over(partition by ID order by ID) as "№ строки", *
from Сотрудник

select rank() over(partition by ID order by Статус), *
from Сотрудник

select dense_rank() over(partition by ID order by Статус), *
from Сотрудник

select ntile(4) over(partition by ID order by Статус), *
from Сотрудник

--------------------------------------------------
-- Задание 12
--------------------------------------------------

select Сотрудник.Фамилия as "Сотрудник", Начальник.Фамилия as "Начальник"
from Сотрудник join Сотрудник as Начальник
on Сотрудник.Начальник = Начальник.ID;

with cte (depth, СотрудникID, НачальникID, Фамилия)
as (
	select 0 as depth, Сотрудник_1.ID, Сотрудник_1.Начальник, Сотрудник_1.Фамилия
	from Сотрудник as Сотрудник_1
	where Сотрудник_1.Начальник is null

	union all

	select cte.depth + 1, Сотрудник_2.ID, Сотрудник_2.Начальник, Сотрудник_2.Фамилия
	from Сотрудник as Сотрудник_2
	inner join cte on Сотрудник_2.Начальник = cte.СотрудникID
)

select replicate('*', depth) + replicate(' ', depth * 2) + ' ' + Фамилия from cte

--------------------------------------------------
-- Задание 13
--------------------------------------------------

set identity_insert Клиент off;

merge Клиент
using Сотрудник
on Клиент.Паспортные_данные = Сотрудник.Паспортные_данные
when not matched by target then
insert values(Фамилия, Имя, Отчество, Номер_мобильного_телефона, Пол, Дата_рождения, Адрес_электронной_почты, Паспортные_данные);
